// Generated by CoffeeScript 1.9.2
(function() {
  var DateTime, Interval, data, prettyList, setup, should;

  should = require('should');

  setup = require('../../setup');

  data = require('./data');

  Interval = require('../../../lib/datatypes/interval').Interval;

  DateTime = require('../../../lib/datatypes/datetime').DateTime;

  describe('Interval', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should properly represent an open interval', function() {
      this.open.lowClosed.should.be["false"]();
      this.open.highClosed.should.be["false"]();
      this.open.low.exec(this.ctx).should.eql(new DateTime(2012, 1, 1));
      return this.open.high.exec(this.ctx).should.eql(new DateTime(2013, 1, 1));
    });
    it('should properly represent a left-open interval', function() {
      this.leftOpen.lowClosed.should.be["false"]();
      this.leftOpen.highClosed.should.be["true"]();
      this.leftOpen.low.exec(this.ctx).should.eql(new DateTime(2012, 1, 1));
      return this.leftOpen.high.exec(this.ctx).should.eql(new DateTime(2013, 1, 1));
    });
    it('should properly represent a right-open interval', function() {
      this.rightOpen.lowClosed.should.be["true"]();
      this.rightOpen.highClosed.should.be["false"]();
      this.rightOpen.low.exec(this.ctx).should.eql(new DateTime(2012, 1, 1));
      return this.rightOpen.high.exec(this.ctx).should.eql(new DateTime(2013, 1, 1));
    });
    it('should properly represent a closed interval', function() {
      this.closed.lowClosed.should.be["true"]();
      this.closed.highClosed.should.be["true"]();
      this.closed.low.exec(this.ctx).should.eql(new DateTime(2012, 1, 1));
      return this.closed.high.exec(this.ctx).should.eql(new DateTime(2013, 1, 1));
    });
    return it('should exec to native Interval datatype', function() {
      var ivl;
      ivl = this.open.exec(this.ctx);
      ivl.should.be.instanceOf(Interval);
      ivl.lowClosed.should.equal(this.open.lowClosed);
      ivl.highClosed.should.equal(this.open.highClosed);
      ivl.low.should.eql(new DateTime(2012, 1, 1));
      return ivl.high.should.eql(new DateTime(2013, 1, 1));
    });
  });

  describe('Equal', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should determine equal integer intervals', function() {
      this.equalClosed.exec(this.ctx).should.be["true"]();
      this.equalOpen.exec(this.ctx).should.be["true"]();
      return this.equalOpenClosed.exec(this.ctx).should.be["true"]();
    });
    it('should determine unequal integer intervals', function() {
      this.unequalClosed.exec(this.ctx).should.be["false"]();
      this.unequalOpen.exec(this.ctx).should.be["false"]();
      return this.unequalClosedOpen.exec(this.ctx).should.be["false"]();
    });
    it('should determine equal quantity intervals', function() {
      this.equalQuantityClosed.exec(this.ctx).should.be["true"]();
      this.equalQuantityOpen.exec(this.ctx).should.be["true"]();
      return this.equalQuantityOpenClosed.exec(this.ctx).should.be["true"]();
    });
    it('should determine unequal quantity intervals', function() {
      this.unequalQuantityClosed.exec(this.ctx).should.be["false"]();
      this.unequalQuantityOpen.exec(this.ctx).should.be["false"]();
      return this.unequalQuantityClosedOpen.exec(this.ctx).should.be["false"]();
    });
    it('should determine equal datetime intervals', function() {
      this.equalDates.exec(this.ctx).should.be["true"]();
      return this.equalDatesOpenClosed.exec(this.ctx).should.be["true"]();
    });
    return it('should operate correctly with imprecision', function() {
      this.sameDays.exec(this.ctx).should.be["true"]();
      this.differentDays.exec(this.ctx).should.be["false"]();
      return should(this.differingPrecision.exec(this.ctx)).be["null"]();
    });
  });

  describe('NotEqual', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should determine equal integer intervals', function() {
      this.equalClosed.exec(this.ctx).should.be["false"]();
      this.equalOpen.exec(this.ctx).should.be["false"]();
      return this.equalOpenClosed.exec(this.ctx).should.be["false"]();
    });
    it('should determine unequal integer intervals', function() {
      this.unequalClosed.exec(this.ctx).should.be["true"]();
      this.unequalOpen.exec(this.ctx).should.be["true"]();
      return this.unequalClosedOpen.exec(this.ctx).should.be["true"]();
    });
    it('should determine equal quantity intervals', function() {
      this.equalQuantityClosed.exec(this.ctx).should.be["false"]();
      this.equalQuantityOpen.exec(this.ctx).should.be["false"]();
      return this.equalQuantityOpenClosed.exec(this.ctx).should.be["false"]();
    });
    it('should determine unequal quantity intervals', function() {
      this.unequalQuantityClosed.exec(this.ctx).should.be["true"]();
      this.unequalQuantityOpen.exec(this.ctx).should.be["true"]();
      return this.unequalQuantityClosedOpen.exec(this.ctx).should.be["true"]();
    });
    it('should determine equal datetime intervals', function() {
      this.equalDates.exec(this.ctx).should.be["false"]();
      return this.equalDatesOpenClosed.exec(this.ctx).should.be["false"]();
    });
    return it('should operate correctly with imprecision', function() {
      this.sameDays.exec(this.ctx).should.be["false"]();
      this.differentDays.exec(this.ctx).should.be["true"]();
      return should(this.differingPrecision.exec(this.ctx)).be["null"]();
    });
  });

  describe('Contains', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept contained items', function() {
      this.containsInt.exec(this.ctx).should.be["true"]();
      this.containsReal.exec(this.ctx).should.be["true"]();
      this.containsQuantity.exec(this.ctx).should.be["true"]();
      this.containsQuantityInclusiveEdge.exec(this.ctx).should.be["true"]();
      return this.containsDate.exec(this.ctx).should.be["true"]();
    });
    it('should reject uncontained items', function() {
      this.notContainsInt.exec(this.ctx).should.be["false"]();
      this.notContainsReal.exec(this.ctx).should.be["false"]();
      this.notContainsQuantity.exec(this.ctx).should.be["false"]();
      this.notContainsQuantityExclusiveEdge.exec(this.ctx).should.be["false"]();
      return this.notContainsDate.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.negInfBegContainsInt.exec(this.ctx).should.be["true"]();
      this.negInfBegNotContainsInt.exec(this.ctx).should.be["false"]();
      this.unknownBegContainsInt.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayContainInt.exec(this.ctx)).be["null"]();
      this.unknownBegNotContainsInt.exec(this.ctx).should.be["false"]();
      this.posInfEndContainsInt.exec(this.ctx).should.be["true"]();
      this.posInfEndNotContainsInt.exec(this.ctx).should.be["false"]();
      this.unknownEndContainsInt.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayContainInt.exec(this.ctx)).be["null"]();
      return this.unknownEndNotContainsInt.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (date)', function() {
      this.negInfBegContainsDate.exec(this.ctx).should.be["true"]();
      this.negInfBegNotContainsDate.exec(this.ctx).should.be["false"]();
      this.unknownBegContainsDate.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayContainDate.exec(this.ctx)).be["null"]();
      this.unknownBegNotContainsDate.exec(this.ctx).should.be["false"]();
      this.posInfEndContainsDate.exec(this.ctx).should.be["true"]();
      this.posInfEndNotContainsDate.exec(this.ctx).should.be["false"]();
      this.unknownEndContainsDate.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayContainDate.exec(this.ctx)).be["null"]();
      return this.unknownEndNotContainsDate.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle imprecision', function() {
      this.containsImpreciseDate.exec(this.ctx).should.be["true"]();
      this.notContainsImpreciseDate.exec(this.ctx).should.be["false"]();
      should(this.mayContainImpreciseDate.exec(this.ctx)).be["null"]();
      this.impreciseContainsDate.exec(this.ctx).should.be["true"]();
      this.impreciseNotContainsDate.exec(this.ctx).should.be["false"]();
      return should(this.impreciseMayContainDate.exec(this.ctx)).be["null"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.containsDayOfDateLowEdge.exec(this.ctx).should.be["true"]();
      this.containsDayOfDateHighEdge.exec(this.ctx).should.be["true"]();
      this.notContainsDayOfDateLowEdge.exec(this.ctx).should.be["false"]();
      this.notContainsDayOfDateHighEdge.exec(this.ctx).should.be["false"]();
      this.containsDayOfDateImpreciseLowEdge.exec(this.ctx).should.be["true"]();
      this.containsDayOfDateImpreciseHighEdge.exec(this.ctx).should.be["true"]();
      this.containsDayOfDateVeryImpreciseMiddle.exec(this.ctx).should.be["true"]();
      this.notContainsDayOfDateVeryImpreciseLow.exec(this.ctx).should.be["false"]();
      this.notContainsDayOfDateVeryImpreciseHigh.exec(this.ctx).should.be["false"]();
      should(this.mayContainDayOfDateVeryImpreciseLow.exec(this.ctx)).be["null"]();
      should(this.mayContainDayOfDateVeryImpreciseHigh.exec(this.ctx)).be["null"]();
      return should(this.mayContainDayOfDateVeryImpreciseSurrounding.exec(this.ctx)).be["null"]();
    });
  });

  describe('In', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept contained items', function() {
      this.containsInt.exec(this.ctx).should.be["true"]();
      this.containsReal.exec(this.ctx).should.be["true"]();
      this.containsQuantity.exec(this.ctx).should.be["true"]();
      this.containsQuantityInclusiveEdge.exec(this.ctx).should.be["true"]();
      return this.containsDate.exec(this.ctx).should.be["true"]();
    });
    it('should reject uncontained items', function() {
      this.notContainsInt.exec(this.ctx).should.be["false"]();
      this.notContainsReal.exec(this.ctx).should.be["false"]();
      this.notContainsQuantity.exec(this.ctx).should.be["false"]();
      this.notContainsQuantityExclusiveEdge.exec(this.ctx).should.be["false"]();
      return this.notContainsDate.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.negInfBegContainsInt.exec(this.ctx).should.be["true"]();
      this.negInfBegNotContainsInt.exec(this.ctx).should.be["false"]();
      this.unknownBegContainsInt.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayContainInt.exec(this.ctx)).be["null"]();
      this.unknownBegNotContainsInt.exec(this.ctx).should.be["false"]();
      this.posInfEndContainsInt.exec(this.ctx).should.be["true"]();
      this.posInfEndNotContainsInt.exec(this.ctx).should.be["false"]();
      this.unknownEndContainsInt.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayContainInt.exec(this.ctx)).be["null"]();
      return this.unknownEndNotContainsInt.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (date)', function() {
      this.negInfBegContainsDate.exec(this.ctx).should.be["true"]();
      this.negInfBegNotContainsDate.exec(this.ctx).should.be["false"]();
      this.unknownBegContainsDate.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayContainDate.exec(this.ctx)).be["null"]();
      this.unknownBegNotContainsDate.exec(this.ctx).should.be["false"]();
      this.posInfEndContainsDate.exec(this.ctx).should.be["true"]();
      this.posInfEndNotContainsDate.exec(this.ctx).should.be["false"]();
      this.unknownEndContainsDate.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayContainDate.exec(this.ctx)).be["null"]();
      return this.unknownEndNotContainsDate.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle imprecision', function() {
      this.containsImpreciseDate.exec(this.ctx).should.be["true"]();
      this.notContainsImpreciseDate.exec(this.ctx).should.be["false"]();
      should(this.mayContainImpreciseDate.exec(this.ctx)).be["null"]();
      this.impreciseContainsDate.exec(this.ctx).should.be["true"]();
      this.impreciseNotContainsDate.exec(this.ctx).should.be["false"]();
      return should(this.impreciseMayContainDate.exec(this.ctx)).be["null"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.containsDayOfDateLowEdge.exec(this.ctx).should.be["true"]();
      this.containsDayOfDateHighEdge.exec(this.ctx).should.be["true"]();
      this.notContainsDayOfDateLowEdge.exec(this.ctx).should.be["false"]();
      this.notContainsDayOfDateHighEdge.exec(this.ctx).should.be["false"]();
      this.containsDayOfDateImpreciseLowEdge.exec(this.ctx).should.be["true"]();
      this.containsDayOfDateImpreciseHighEdge.exec(this.ctx).should.be["true"]();
      this.containsDayOfDateVeryImpreciseMiddle.exec(this.ctx).should.be["true"]();
      this.notContainsDayOfDateVeryImpreciseLow.exec(this.ctx).should.be["false"]();
      this.notContainsDayOfDateVeryImpreciseHigh.exec(this.ctx).should.be["false"]();
      should(this.mayContainDayOfDateVeryImpreciseLow.exec(this.ctx)).be["null"]();
      should(this.mayContainDayOfDateVeryImpreciseHigh.exec(this.ctx)).be["null"]();
      return should(this.mayContainDayOfDateVeryImpreciseSurrounding.exec(this.ctx)).be["null"]();
    });
  });

  describe('Includes', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept included items', function() {
      this.includesIntIvl.exec(this.ctx).should.be["true"]();
      this.includesRealIvl.exec(this.ctx).should.be["true"]();
      return this.includesDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject unincluded items', function() {
      this.notIncludesIntIvl.exec(this.ctx).should.be["false"]();
      this.notIncludesRealIvl.exec(this.ctx).should.be["false"]();
      return this.notIncludesDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.negInfBegIncludesIntIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotIncludesIntIvl.exec(this.ctx).should.be["false"]();
      this.unknownBegIncludesIntIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayIncludeIntIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotIncludesIntIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndIncludesIntIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotIncludesIntIvl.exec(this.ctx).should.be["false"]();
      this.unknownEndIncludesIntIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayIncludeIntIvl.exec(this.ctx)).be["null"]();
      return this.unknownEndNotIncludesIntIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (date)', function() {
      this.negInfBegIncludesDateIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotIncludesDateIvl.exec(this.ctx).should.be["false"]();
      this.unknownBegIncludesDateIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayIncludeDateIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotIncludesDateIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndIncludesDateIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotIncludesDateIvl.exec(this.ctx).should.be["false"]();
      this.unknownEndIncludesDateIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayIncludeDateIvl.exec(this.ctx)).be["null"]();
      return this.unknownEndNotIncludesDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle imprecision', function() {
      this.includesImpreciseDateIvl.exec(this.ctx).should.be["true"]();
      this.notIncludesImpreciseDateIvl.exec(this.ctx).should.be["false"]();
      should(this.mayIncludeImpreciseDateIvl.exec(this.ctx)).be["null"]();
      this.impreciseIncludesDateIvl.exec(this.ctx).should.be["true"]();
      this.impreciseNotIncludesDateIvl.exec(this.ctx).should.be["false"]();
      return should(this.impreciseMayIncludeDateIvl.exec(this.ctx)).be["null"]();
    });
    it('should correctly compare using the requested precision', function() {
      this.includesDayOfIvlLowEdge.exec(this.ctx).should.be["true"]();
      this.includesDayOfIvlHighEdge.exec(this.ctx).should.be["true"]();
      this.notIncludesDayOfIvlLowEdge.exec(this.ctx).should.be["false"]();
      this.notIncludesDayOfIvlHighEdge.exec(this.ctx).should.be["false"]();
      this.includesDayOfIvlImpreciseLowEdge.exec(this.ctx).should.be["true"]();
      this.includesDayOfIvlImpreciseHighEdge.exec(this.ctx).should.be["true"]();
      this.includesDayOfIvlVeryImpreciseMiddle.exec(this.ctx).should.be["true"]();
      this.notIncludesDayOfIvlVeryImpreciseLow.exec(this.ctx).should.be["false"]();
      this.notIncludesDayOfIvlVeryImpreciseHigh.exec(this.ctx).should.be["false"]();
      should(this.mayIncludeDayOfIvlVeryImpreciseLow.exec(this.ctx)).be["null"]();
      should(this.mayIncludeDayOfIvlVeryImpreciseHigh.exec(this.ctx)).be["null"]();
      return should(this.mayIncludeDayOfIvlVeryImpreciseSurrounding.exec(this.ctx)).be["null"]();
    });
    return it('should correctly handle point inclusion', function() {
      this.impreciseIncludesDate.exec(this.ctx).should.be["true"]();
      this.impreciseDoesntIncludeDate.exec(this.ctx).should.be["false"]();
      this.intervalIncludesQuantity.exec(this.ctx).should.be["true"]();
      return this.intervalDoesntIncludeQuantity.exec(this.ctx).should.be["false"]();
    });
  });

  describe('ProperlyIncludes', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept properly included intervals', function() {
      this.properlyIncludesIntIvl.exec(this.ctx).should.be["true"]();
      this.properlyIncludesIntBeginsIvl.exec(this.ctx).should.be["true"]();
      this.properlyIncludesIntEndsIvl.exec(this.ctx).should.be["true"]();
      this.properlyIncludesRealIvl.exec(this.ctx).should.be["true"]();
      return this.properlyIncludesDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject intervals not properly included', function() {
      this.notProperlyIncludesIntIvl.exec(this.ctx).should.be["false"]();
      this.notProperlyIncludesRealIvl.exec(this.ctx).should.be["false"]();
      return this.notProperlyIncludesDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.posInfEndProperlyIncludesIntIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotProperlyIncludesIntIvl.exec(this.ctx).should.be["false"]();
      return should(this.unknownEndMayProperlyIncludeIntIvl.exec(this.ctx)).be["null"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.properlyIncludesDayOfIvlLowEdge.exec(this.ctx).should.be["true"]();
      this.properlyIncludesDayOfIvlHighEdge.exec(this.ctx).should.be["true"]();
      this.properlyIncludesDayOfIvlNearEdges.exec(this.ctx).should.be["true"]();
      this.notProperlyIncludesDayOfIvlSameEdges.exec(this.ctx).should.be["false"]();
      should(this.mayProperlyIncludeDayOfIvlVeryImpreciseLow.exec(this.ctx)).be["null"]();
      should(this.mayProperlyIncludeDayOfIvlVeryImpreciseHigh.exec(this.ctx)).be["null"]();
      should(this.mayProperlyIncludeDayOfIvlVeryImpreciseLowAndHigh.exec(this.ctx)).be["null"]();
      return should(this.mayProperlyIncludeDayOfIvlVeryImpreciseSurrounding.exec(this.ctx)).be["null"]();
    });
  });

  describe('IncludedIn', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept included items', function() {
      this.includesIntIvl.exec(this.ctx).should.be["true"]();
      this.includesRealIvl.exec(this.ctx).should.be["true"]();
      return this.includesDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject unincluded items', function() {
      this.notIncludesIntIvl.exec(this.ctx).should.be["false"]();
      this.notIncludesRealIvl.exec(this.ctx).should.be["false"]();
      return this.notIncludesDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.negInfBegIncludedInIntIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotIncludedInIntIvl.exec(this.ctx).should.be["false"]();
      this.unknownBegIncludedInIntIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayBeIncludedInIntIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotIncludedInIntIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndIncludedInIntIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotIncludedInIntIvl.exec(this.ctx).should.be["false"]();
      this.unknownEndIncludedInIntIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayBeIncludedInIntIvl.exec(this.ctx)).be["null"]();
      return this.unknownEndNotIncludedInIntIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (date)', function() {
      this.negInfBegIncludedInDateIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotIncludedInDateIvl.exec(this.ctx).should.be["false"]();
      this.unknownBegIncludedInDateIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayBeIncludedInDateIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotIncludedInDateIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndIncludedInDateIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotIncludedInDateIvl.exec(this.ctx).should.be["false"]();
      this.unknownEndIncludedInDateIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayBeIncludedInDateIvl.exec(this.ctx)).be["null"]();
      return this.unknownEndNotIncludedInDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle imprecision', function() {
      this.includesImpreciseDateIvl.exec(this.ctx).should.be["true"]();
      this.notIncludesImpreciseDateIvl.exec(this.ctx).should.be["false"]();
      should(this.mayIncludeImpreciseDateIvl.exec(this.ctx)).be["null"]();
      this.impreciseIncludesDateIvl.exec(this.ctx).should.be["true"]();
      this.impreciseNotIncludesDateIvl.exec(this.ctx).should.be["false"]();
      return should(this.impreciseMayIncludeDateIvl.exec(this.ctx)).be["null"]();
    });
    it('should correctly compare using the requested precision', function() {
      this.includesDayOfIvlLowEdge.exec(this.ctx).should.be["true"]();
      this.includesDayOfIvlHighEdge.exec(this.ctx).should.be["true"]();
      this.notIncludesDayOfIvlLowEdge.exec(this.ctx).should.be["false"]();
      this.notIncludesDayOfIvlHighEdge.exec(this.ctx).should.be["false"]();
      this.includesDayOfIvlImpreciseLowEdge.exec(this.ctx).should.be["true"]();
      this.includesDayOfIvlImpreciseHighEdge.exec(this.ctx).should.be["true"]();
      this.includesDayOfIvlVeryImpreciseMiddle.exec(this.ctx).should.be["true"]();
      this.notIncludesDayOfIvlVeryImpreciseLow.exec(this.ctx).should.be["false"]();
      this.notIncludesDayOfIvlVeryImpreciseHigh.exec(this.ctx).should.be["false"]();
      should(this.mayIncludeDayOfIvlVeryImpreciseLow.exec(this.ctx)).be["null"]();
      should(this.mayIncludeDayOfIvlVeryImpreciseHigh.exec(this.ctx)).be["null"]();
      return should(this.mayIncludeDayOfIvlVeryImpreciseSurrounding.exec(this.ctx)).be["null"]();
    });
    return it('should correctly handle point comparisons', function() {
      this.includesDayInInterval.exec(this.ctx).should.be["true"]();
      this.doesNotIncludeDayInInterval.exec(this.ctx).should.be["false"]();
      this.quantityIncludedInterval.exec(this.ctx).should.be["true"]();
      return this.quantityNotIncludedInterval.exec(this.ctx).should.be["false"]();
    });
  });

  describe('ProperlyIncludedIn', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept properly included intervals', function() {
      this.properlyIncludesIntIvl.exec(this.ctx).should.be["true"]();
      this.properlyIncludesIntBeginsIvl.exec(this.ctx).should.be["true"]();
      this.properlyIncludesIntEndsIvl.exec(this.ctx).should.be["true"]();
      this.properlyIncludesRealIvl.exec(this.ctx).should.be["true"]();
      return this.properlyIncludesDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject intervals not properly included', function() {
      this.notProperlyIncludesIntIvl.exec(this.ctx).should.be["false"]();
      this.notProperlyIncludesRealIvl.exec(this.ctx).should.be["false"]();
      return this.notProperlyIncludesDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.posInfEndProperlyIncludedInDateIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotProperlyIncludedInDateIvl.exec(this.ctx).should.be["false"]();
      return should(this.unknownEndMayBeProperlyIncludedInDateIvl.exec(this.ctx)).be["null"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.properlyIncludesDayOfIvlLowEdge.exec(this.ctx).should.be["true"]();
      this.properlyIncludesDayOfIvlHighEdge.exec(this.ctx).should.be["true"]();
      this.properlyIncludesDayOfIvlNearEdges.exec(this.ctx).should.be["true"]();
      this.notProperlyIncludesDayOfIvlSameEdges.exec(this.ctx).should.be["false"]();
      should(this.mayProperlyIncludeDayOfIvlVeryImpreciseLow.exec(this.ctx)).be["null"]();
      should(this.mayProperlyIncludeDayOfIvlVeryImpreciseHigh.exec(this.ctx)).be["null"]();
      should(this.mayProperlyIncludeDayOfIvlVeryImpreciseLowAndHigh.exec(this.ctx)).be["null"]();
      return should(this.mayProperlyIncludeDayOfIvlVeryImpreciseSurrounding.exec(this.ctx)).be["null"]();
    });
  });

  describe('After', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept intervals before it', function() {
      this.afterIntIvl.exec(this.ctx).should.be["true"]();
      this.afterRealIvl.exec(this.ctx).should.be["true"]();
      return this.afterDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject intervals on or after it', function() {
      this.notAfterIntIvl.exec(this.ctx).should.be["false"]();
      this.notAfterRealIvl.exec(this.ctx).should.be["false"]();
      return this.notAfterDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.negInfBegNotAfterIntIvl.exec(this.ctx).should.be["false"]();
      should(this.unknownBegMayBeAfterIntIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotAfterIntIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndAfterIntIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotAfterIntIvl.exec(this.ctx).should.be["false"]();
      this.unknownEndAfterIntIvl.exec(this.ctx).should.be["true"]();
      return this.unknownEndNotAfterIntIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (date)', function() {
      this.negInfBegNotAfterDateIvl.exec(this.ctx).should.be["false"]();
      should(this.unknownBegMayBeAfterDateIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotAfterDateIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndAfterDateIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotAfterDateIvl.exec(this.ctx).should.be["false"]();
      this.unknownEndAfterDateIvl.exec(this.ctx).should.be["true"]();
      return this.unknownEndNotAfterDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle imprecision', function() {
      this.afterImpreciseDateIvl.exec(this.ctx).should.be["true"]();
      should(this.notAfterImpreciseDateIvl.exec(this.ctx)).be["null"]();
      should(this.mayBeAfterImpreciseDateIvl.exec(this.ctx)).be["null"]();
      this.impreciseAfterDateIvl.exec(this.ctx).should.be["true"]();
      should(this.impreciseNotAfterDateIvl.exec(this.ctx)).be["null"]();
      return should(this.impreciseMayBeAfterDateIvl.exec(this.ctx)).be["null"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.afterDayOfIvl.exec(this.ctx).should.be["true"]();
      this.beforeDayOfIvl.exec(this.ctx).should.be["false"]();
      this.startsSameDayOfIvlEnd.exec(this.ctx).should.be["false"]();
      this.endsSameDayOfIvlStart.exec(this.ctx).should.be["false"]();
      should(this.mayBeAfterDayOfImpreciseIvl.exec(this.ctx)).be["null"]();
      return this.mayBeBeforeDayOfImpreciseIvl.exec(this.ctx).should.be["false"]();
    });
  });

  describe('Before', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept intervals before it', function() {
      this.beforeIntIvl.exec(this.ctx).should.be["true"]();
      this.beforeRealIvl.exec(this.ctx).should.be["true"]();
      return this.beforeDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject intervals on or after it', function() {
      this.notBeforeIntIvl.exec(this.ctx).should.be["false"]();
      this.notBeforeRealIvl.exec(this.ctx).should.be["false"]();
      return this.notBeforeDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.negInfBegBeforeIntIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotBeforeIntIvl.exec(this.ctx).should.be["false"]();
      this.unknownBegBeforeIntIvl.exec(this.ctx).should.be["true"]();
      this.unknownBegNotBeforeIntIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndNotBeforeIntIvl.exec(this.ctx).should.be["false"]();
      should(this.unknownEndMayBeBeforeIntIvl.exec(this.ctx)).be["null"]();
      return this.unknownEndNotBeforeIntIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (date)', function() {
      this.negInfBegBeforeDateIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotBeforeDateIvl.exec(this.ctx).should.be["false"]();
      this.unknownBegBeforeDateIvl.exec(this.ctx).should.be["true"]();
      this.unknownBegNotBeforeDateIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndNotBeforeDateIvl.exec(this.ctx).should.be["false"]();
      should(this.unknownEndMayBeBeforeDateIvl.exec(this.ctx)).be["null"]();
      return this.unknownEndNotBeforeDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle imprecision', function() {
      this.beforeImpreciseDateIvl.exec(this.ctx).should.be["true"]();
      should(this.notBeforeImpreciseDateIvl.exec(this.ctx)).be["null"]();
      should(this.mayBeBeforeImpreciseDateIvl.exec(this.ctx)).be["null"]();
      this.impreciseBeforeDateIvl.exec(this.ctx).should.be["true"]();
      should(this.impreciseNotBeforeDateIvl.exec(this.ctx)).be["null"]();
      return should(this.impreciseMayBeBeforeDateIvl.exec(this.ctx)).be["null"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.afterDayOfIvl.exec(this.ctx).should.be["false"]();
      this.beforeDayOfIvl.exec(this.ctx).should.be["true"]();
      this.startsSameDayOfIvlEnd.exec(this.ctx).should.be["false"]();
      this.endsSameDayOfIvlStart.exec(this.ctx).should.be["false"]();
      this.mayBeAfterDayOfImpreciseIvl.exec(this.ctx).should.be["false"]();
      return should(this.mayBeBeforeDayOfImpreciseIvl.exec(this.ctx)).be["null"]();
    });
  });

  describe('Meets', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept intervals meeting after it', function() {
      this.meetsBeforeIntIvl.exec(this.ctx).should.be["true"]();
      this.meetsBeforeRealIvl.exec(this.ctx).should.be["true"]();
      return this.meetsBeforeDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should accept intervals meeting before it', function() {
      this.meetsAfterIntIvl.exec(this.ctx).should.be["true"]();
      this.meetsAfterRealIvl.exec(this.ctx).should.be["true"]();
      return this.meetsAfterDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject intervals not meeting it', function() {
      this.notMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.notMeetsRealIvl.exec(this.ctx).should.be["false"]();
      return this.notMeetsDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.negInfBegMeetsBeforeIntIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.intIvlNotMeetsNegInfBeg.exec(this.ctx).should.be["false"]();
      this.unknownBegMeetsBeforeIntIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayMeetAfterIntIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      should(this.intIvlMayMeetBeforeUnknownBeg.exec(this.ctx)).be["null"]();
      this.posInfEndMeetsAfterIntIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.intIvlNotMeetsPosInfEnd.exec(this.ctx).should.be["false"]();
      this.unknownEndMeetsAfterIntIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayMeetBeforeIntIvl.exec(this.ctx)).be["null"]();
      this.unknownEndNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      return should(this.intIvlMayMeetAfterUnknownEnd.exec(this.ctx)).be["null"]();
    });
    it('should correctly handle null endpoints (date)', function() {
      this.negInfBegMeetsBeforeDateIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      this.dateIvlNotMeetsNegInfBeg.exec(this.ctx).should.be["false"]();
      this.unknownBegMeetsBeforeDateIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownBegMayMeetAfterDateIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      should(this.dateIvlMayMeetBeforeUnknownBeg.exec(this.ctx)).be["null"]();
      this.posInfEndMeetsAfterDateIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      this.dateIvlNotMeetsPosInfEnd.exec(this.ctx).should.be["false"]();
      this.unknownEndMeetsAfterDateIvl.exec(this.ctx).should.be["true"]();
      should(this.unknownEndMayMeetBeforeDateIvl.exec(this.ctx)).be["null"]();
      this.unknownEndNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      return should(this.dateIvlMayMeetAfterUnknownEnd.exec(this.ctx)).be["null"]();
    });
    it('should correctly handle imprecision', function() {
      should(this.mayMeetAfterImpreciseDateIvl.exec(this.ctx)).be["null"]();
      should(this.mayMeetBeforeImpreciseDateIvl.exec(this.ctx)).be["null"]();
      this.notMeetsImpreciseDateIvl.exec(this.ctx).should.be["false"]();
      should(this.impreciseMayMeetAfterDateIvl.exec(this.ctx)).be["null"]();
      should(this.impreciseMayMeetBeforeDateIvl.exec(this.ctx)).be["null"]();
      return this.impreciseNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.meetsAfterDayOfIvl.exec(this.ctx).should.be["true"]();
      this.meetsBeforeDayOfIvl.exec(this.ctx).should.be["true"]();
      this.notMeetsDayOfIvl.exec(this.ctx).should.be["false"]();
      this.notMeetsDayOfImpreciseIVL.exec(this.ctx).should.be["false"]();
      should(this.mayMeetAfterDayOfImpreciseIvl.exec(this.ctx)).be["null"]();
      return should(this.mayMeetBeforeDayOfImpreciseIvl.exec(this.ctx)).be["null"]();
    });
  });

  describe('MeetsAfter', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept intervals meeting before it', function() {
      this.meetsAfterIntIvl.exec(this.ctx).should.be["true"]();
      this.meetsAfterRealIvl.exec(this.ctx).should.be["true"]();
      return this.meetsAfterDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject intervals meeting after it', function() {
      this.meetsBeforeIntIvl.exec(this.ctx).should.be["false"]();
      this.meetsBeforeRealIvl.exec(this.ctx).should.be["false"]();
      return this.meetsBeforeDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should reject intervals not meeting it', function() {
      this.notMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.notMeetsRealIvl.exec(this.ctx).should.be["false"]();
      return this.notMeetsDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.negInfBegMeetsBeforeIntIvl.exec(this.ctx).should.be["false"]();
      this.negInfBegNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.intIvlNotMeetsNegInfBeg.exec(this.ctx).should.be["false"]();
      this.unknownBegMeetsBeforeIntIvl.exec(this.ctx).should.be["false"]();
      should(this.unknownBegMayMeetAfterIntIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.intIvlMayMeetBeforeUnknownBeg.exec(this.ctx).should.be["false"]();
      this.posInfEndMeetsAfterIntIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.intIvlNotMeetsPosInfEnd.exec(this.ctx).should.be["false"]();
      this.unknownEndMeetsAfterIntIvl.exec(this.ctx).should.be["true"]();
      this.unknownEndMayMeetBeforeIntIvl.exec(this.ctx).should.be["false"]();
      this.unknownEndNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      return should(this.intIvlMayMeetAfterUnknownEnd.exec(this.ctx)).be["null"]();
    });
    it('should correctly handle null endpoints (date)', function() {
      this.negInfBegMeetsBeforeDateIvl.exec(this.ctx).should.be["false"]();
      this.negInfBegNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      this.dateIvlNotMeetsNegInfBeg.exec(this.ctx).should.be["false"]();
      this.unknownBegMeetsBeforeDateIvl.exec(this.ctx).should.be["false"]();
      should(this.unknownBegMayMeetAfterDateIvl.exec(this.ctx)).be["null"]();
      this.unknownBegNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      this.dateIvlMayMeetBeforeUnknownBeg.exec(this.ctx).should.be["false"]();
      this.posInfEndMeetsAfterDateIvl.exec(this.ctx).should.be["true"]();
      this.posInfEndNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      this.dateIvlNotMeetsPosInfEnd.exec(this.ctx).should.be["false"]();
      this.unknownEndMeetsAfterDateIvl.exec(this.ctx).should.be["true"]();
      this.unknownEndMayMeetBeforeDateIvl.exec(this.ctx).should.be["false"]();
      this.unknownEndNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      return should(this.dateIvlMayMeetAfterUnknownEnd.exec(this.ctx)).be["null"]();
    });
    it('should correctly handle imprecision', function() {
      should(this.mayMeetAfterImpreciseDateIvl.exec(this.ctx)).be["null"]();
      this.mayMeetBeforeImpreciseDateIvl.exec(this.ctx).should.be["false"]();
      this.notMeetsImpreciseDateIvl.exec(this.ctx).should.be["false"]();
      should(this.impreciseMayMeetAfterDateIvl.exec(this.ctx)).be["null"]();
      this.impreciseMayMeetBeforeDateIvl.exec(this.ctx).should.be["false"]();
      return this.impreciseNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.meetsAfterDayOfIvl.exec(this.ctx).should.be["true"]();
      this.meetsBeforeDayOfIvl.exec(this.ctx).should.be["false"]();
      this.notMeetsDayOfIvl.exec(this.ctx).should.be["false"]();
      this.notMeetsDayOfImpreciseIVL.exec(this.ctx).should.be["false"]();
      should(this.mayMeetAfterDayOfImpreciseIvl.exec(this.ctx)).be["null"]();
      return this.mayMeetBeforeDayOfImpreciseIvl.exec(this.ctx).should.be["false"]();
    });
  });

  describe('MeetsBefore', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept intervals meeting after it', function() {
      this.meetsBeforeIntIvl.exec(this.ctx).should.be["true"]();
      this.meetsBeforeRealIvl.exec(this.ctx).should.be["true"]();
      return this.meetsBeforeDateIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject intervals meeting before it', function() {
      this.meetsAfterIntIvl.exec(this.ctx).should.be["false"]();
      this.meetsAfterRealIvl.exec(this.ctx).should.be["false"]();
      return this.meetsAfterDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should reject intervals not meeting it', function() {
      this.notMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.notMeetsRealIvl.exec(this.ctx).should.be["false"]();
      return this.notMeetsDateIvl.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (int)', function() {
      this.negInfBegMeetsBeforeIntIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.intIvlNotMeetsNegInfBeg.exec(this.ctx).should.be["false"]();
      this.unknownBegMeetsBeforeIntIvl.exec(this.ctx).should.be["true"]();
      this.unknownBegMayMeetAfterIntIvl.exec(this.ctx).should.be["false"]();
      this.unknownBegNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      should(this.intIvlMayMeetBeforeUnknownBeg.exec(this.ctx)).be["null"]();
      this.posInfEndMeetsAfterIntIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      this.intIvlNotMeetsPosInfEnd.exec(this.ctx).should.be["false"]();
      this.unknownEndMeetsAfterIntIvl.exec(this.ctx).should.be["false"]();
      should(this.unknownEndMayMeetBeforeIntIvl.exec(this.ctx)).be["null"]();
      this.unknownEndNotMeetsIntIvl.exec(this.ctx).should.be["false"]();
      return this.intIvlMayMeetAfterUnknownEnd.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle null endpoints (date)', function() {
      this.negInfBegMeetsBeforeDateIvl.exec(this.ctx).should.be["true"]();
      this.negInfBegNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      this.dateIvlNotMeetsNegInfBeg.exec(this.ctx).should.be["false"]();
      this.unknownBegMeetsBeforeDateIvl.exec(this.ctx).should.be["true"]();
      this.unknownBegMayMeetAfterDateIvl.exec(this.ctx).should.be["false"]();
      this.unknownBegNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      should(this.dateIvlMayMeetBeforeUnknownBeg.exec(this.ctx)).be["null"]();
      this.posInfEndMeetsAfterDateIvl.exec(this.ctx).should.be["false"]();
      this.posInfEndNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      this.dateIvlNotMeetsPosInfEnd.exec(this.ctx).should.be["false"]();
      this.unknownEndMeetsAfterDateIvl.exec(this.ctx).should.be["false"]();
      should(this.unknownEndMayMeetBeforeDateIvl.exec(this.ctx)).be["null"]();
      this.unknownEndNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
      return this.dateIvlMayMeetAfterUnknownEnd.exec(this.ctx).should.be["false"]();
    });
    it('should correctly handle imprecision', function() {
      this.mayMeetAfterImpreciseDateIvl.exec(this.ctx).should.be["false"]();
      should(this.mayMeetBeforeImpreciseDateIvl.exec(this.ctx)).be["null"]();
      this.notMeetsImpreciseDateIvl.exec(this.ctx).should.be["false"]();
      this.impreciseMayMeetAfterDateIvl.exec(this.ctx).should.be["false"]();
      should(this.impreciseMayMeetBeforeDateIvl.exec(this.ctx)).be["null"]();
      return this.impreciseNotMeetsDateIvl.exec(this.ctx).should.be["false"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.meetsAfterDayOfIvl.exec(this.ctx).should.be["false"]();
      this.meetsBeforeDayOfIvl.exec(this.ctx).should.be["true"]();
      this.notMeetsDayOfIvl.exec(this.ctx).should.be["false"]();
      this.notMeetsDayOfImpreciseIVL.exec(this.ctx).should.be["false"]();
      this.mayMeetAfterDayOfImpreciseIvl.exec(this.ctx).should.be["false"]();
      return should(this.mayMeetBeforeDayOfImpreciseIvl.exec(this.ctx)).be["null"]();
    });
  });

  describe('Overlaps', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept overlaps (integer)', function() {
      this.overlapsBeforeIntIvl.exec(this.ctx).should.be["true"]();
      this.overlapsAfterIntIvl.exec(this.ctx).should.be["true"]();
      return this.overlapsBoundaryIntIvl.exec(this.ctx).should.be["true"]();
    });
    it('should accept overlaps (real)', function() {
      this.overlapsBeforeRealIvl.exec(this.ctx).should.be["true"]();
      this.overlapsAfterRealIvl.exec(this.ctx).should.be["true"]();
      return this.overlapsBoundaryRealIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject non-overlaps (integer)', function() {
      return this.noOverlapsIntIvl.exec(this.ctx).should.be["false"]();
    });
    return it('should reject non-overlaps (real)', function() {
      return this.noOverlapsRealIvl.exec(this.ctx).should.be["false"]();
    });
  });

  describe('OverlapsDateTime', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept overlaps', function() {
      this.overlapsBefore.exec(this.ctx).should.be["true"]();
      this.overlapsAfter.exec(this.ctx).should.be["true"]();
      this.overlapsContained.exec(this.ctx).should.be["true"]();
      return this.overlapsContains.exec(this.ctx).should.be["true"]();
    });
    it('should accept imprecise overlaps', function() {
      return this.impreciseOverlap.exec(this.ctx).should.be["true"]();
    });
    it('should reject non-overlaps', function() {
      return this.noOverlap.exec(this.ctx).should.be["false"]();
    });
    it('should reject imprecise non-overlaps', function() {
      return this.noImpreciseOverlap.exec(this.ctx).should.be["false"]();
    });
    it('should return null for imprecise overlaps with differing precision', function() {
      return should(this.unknownOverlap.exec(this.ctx)).be["null"]();
    });
    it('should return true for imprecise overlaps with matching precision', function() {
      return this.matchingPrecisionOverlap.exec(this.ctx).should.be["true"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.overlapsAfterDayOfIvlEdge.exec(this.ctx).should.be["true"]();
      this.overlapsContainsDayOfIvl.exec(this.ctx).should.be["true"]();
      this.notOverlapsDayOfIvl.exec(this.ctx).should.be["false"]();
      this.overlapsAfterDayOfImpreciseInterval.exec(this.ctx).should.be["true"]();
      return should(this.mayOverlapAfterDayOfImpreciseIvl.exec(this.ctx)).be["null"]();
    });
  });

  describe('OverlapsAfter', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept overlaps that are after (integer)', function() {
      this.overlapsAfterIntIvl.exec(this.ctx).should.be["true"]();
      return this.overlapsBoundaryIntIvl.exec(this.ctx).should.be["true"]();
    });
    it('should accept overlaps that are after (real)', function() {
      this.overlapsAfterRealIvl.exec(this.ctx).should.be["true"]();
      return this.overlapsBoundaryRealIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject overlaps that are before (integer)', function() {
      return this.overlapsBeforeIntIvl.exec(this.ctx).should.be["false"]();
    });
    it('should reject overlaps that are before (real)', function() {
      return this.overlapsBeforeRealIvl.exec(this.ctx).should.be["false"]();
    });
    it('should reject non-overlaps (integer)', function() {
      return this.noOverlapsIntIvl.exec(this.ctx).should.be["false"]();
    });
    return it('should reject non-overlaps (real)', function() {
      return this.noOverlapsRealIvl.exec(this.ctx).should.be["false"]();
    });
  });

  describe('OverlapsAfterDateTime', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept overlaps that are after', function() {
      this.overlapsAfter.exec(this.ctx).should.be["true"]();
      return this.overlapsContains.exec(this.ctx).should.be["true"]();
    });
    it('should accept imprecise overlaps that are after', function() {
      return this.impreciseOverlapAfter.exec(this.ctx).should.be["true"]();
    });
    it('should reject overlaps that are not before', function() {
      this.overlapsBefore.exec(this.ctx).should.be["false"]();
      return this.overlapsContained.exec(this.ctx).should.be["false"]();
    });
    it('should reject imprecise overlaps that are not before', function() {
      return this.impreciseOverlapBefore.exec(this.ctx).should.be["false"]();
    });
    it('should reject non-overlaps', function() {
      return this.noOverlap.exec(this.ctx).should.be["false"]();
    });
    it('should reject imprecise non-overlaps', function() {
      return this.noImpreciseOverlap.exec(this.ctx).should.be["false"]();
    });
    it('should return true for imprecise overlaps with matching precision', function() {
      return this.matchingPrecisionOverlap.exec(this.ctx).should.be["true"]();
    });
    it('should return null for imprecise overlaps that are unknown', function() {
      return should(this.unknownOverlap.exec(this.ctx)).be["null"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.overlapsBeforeDayOfIvlEdge.exec(this.ctx).should.be["false"]();
      this.overlapsAfterDayOfIvlEdge.exec(this.ctx).should.be["true"]();
      this.overlapsContainsDayOfIvl.exec(this.ctx).should.be["true"]();
      this.overlapsContainedByDayOfIvl.exec(this.ctx).should.be["false"]();
      this.notOverlapsDayOfIvl.exec(this.ctx).should.be["false"]();
      this.overlapsAfterDayOfImpreciseInterval.exec(this.ctx).should.be["true"]();
      this.mayOverlapBeforeDayOfImpreciseIvl.exec(this.ctx).should.be["false"]();
      return should(this.mayOverlapAfterDayOfImpreciseIvl.exec(this.ctx)).be["null"]();
    });
  });

  describe('OverlapsBefore', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept overlaps that are before (integer)', function() {
      this.overlapsBeforeIntIvl.exec(this.ctx).should.be["true"]();
      return this.overlapsBoundaryIntIvl.exec(this.ctx).should.be["true"]();
    });
    it('should accept overlaps that are before (real)', function() {
      this.overlapsBeforeRealIvl.exec(this.ctx).should.be["true"]();
      return this.overlapsBoundaryRealIvl.exec(this.ctx).should.be["true"]();
    });
    it('should reject overlaps that are after (integer)', function() {
      return this.overlapsAfterIntIvl.exec(this.ctx).should.be["false"]();
    });
    it('should reject overlaps that are after (real)', function() {
      return this.overlapsAfterRealIvl.exec(this.ctx).should.be["false"]();
    });
    it('should reject non-overlaps (integer)', function() {
      return this.noOverlapsIntIvl.exec(this.ctx).should.be["false"]();
    });
    return it('should reject non-overlaps (real)', function() {
      return this.noOverlapsRealIvl.exec(this.ctx).should.be["false"]();
    });
  });

  describe('OverlapsBeforeDateTime', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should accept overlaps that are before', function() {
      this.overlapsBefore.exec(this.ctx).should.be["true"]();
      return this.overlapsContains.exec(this.ctx).should.be["true"]();
    });
    it('should accept imprecise overlaps that are before', function() {
      return this.impreciseOverlapBefore.exec(this.ctx).should.be["true"]();
    });
    it('should reject overlaps that are not before', function() {
      this.overlapsAfter.exec(this.ctx).should.be["false"]();
      return this.overlapsContained.exec(this.ctx).should.be["false"]();
    });
    it('should reject imprecise overlaps that are not before', function() {
      return this.impreciseOverlapAfter.exec(this.ctx).should.be["false"]();
    });
    it('should reject non-overlaps', function() {
      return this.noOverlap.exec(this.ctx).should.be["false"]();
    });
    it('should reject imprecise non-overlaps', function() {
      return this.noImpreciseOverlap.exec(this.ctx).should.be["false"]();
    });
    it('should return true for imprecise overlaps with matching precision', function() {
      return this.matchingPrecisionOverlap.exec(this.ctx).should.be["true"]();
    });
    it('should return null for imprecise overlaps that are unknown', function() {
      return should(this.unknownOverlap.exec(this.ctx)).be["null"]();
    });
    return it('should correctly compare using the requested precision', function() {
      this.overlapsBeforeDayOfIvlEdge.exec(this.ctx).should.be["true"]();
      this.overlapsAfterDayOfIvlEdge.exec(this.ctx).should.be["false"]();
      this.overlapsContainsDayOfIvl.exec(this.ctx).should.be["true"]();
      this.overlapsContainedByDayOfIvl.exec(this.ctx).should.be["false"]();
      this.notOverlapsDayOfIvl.exec(this.ctx).should.be["false"]();
      this.overlapsAfterDayOfImpreciseInterval.exec(this.ctx).should.be["false"]();
      should(this.mayOverlapBeforeDayOfImpreciseIvl.exec(this.ctx)).be["null"]();
      return this.mayOverlapAfterDayOfImpreciseIvl.exec(this.ctx).should.be["false"]();
    });
  });

  describe('Width', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should calculate the width of integer intervals', function() {
      this.intWidth.exec(this.ctx).should.equal(7);
      return this.intOpenWidth.exec(this.ctx).should.equal(5);
    });
    it('should calculate the width of real intervals', function() {
      this.realWidth.exec(this.ctx).should.equal(3.33);
      return this.realOpenWidth.exec(this.ctx).should.equal(3.32999998);
    });
    it('should calculate the width of infinite intervals', function() {
      this.intWidthThreeToMax.exec(this.ctx).should.equal(Math.pow(2, 31) - 4);
      return this.intWidthMinToThree.exec(this.ctx).should.equal(Math.pow(2, 31) + 3);
    });
    return it('should calculate the width of infinite intervals', function() {
      should(this.intWidthThreeToUnknown.exec(this.ctx)).be["null"]();
      return should(this.intWidthUnknownToThree.exec(this.ctx)).be["null"]();
    });
  });

  describe('Start', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    return it('should execute as the start of the interval', function() {
      return this.foo.exec(this.ctx).should.eql(new DateTime(2012, 1, 1));
    });
  });

  describe('End', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    return it('should execute as the end of the interval', function() {
      return this.foo.exec(this.ctx).should.eql(new DateTime(2013, 1, 1));
    });
  });

  describe('Starts', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should calculate to null', function() {
      return should(this.testStartsNull.exec(this.ctx)).be["null"]();
    });
    it('should calculate integer intervals properly', function() {
      this.integerIntervalStartsTrue.exec(this.ctx).should.be["true"]();
      this.integerIntervalStartsFalse.exec(this.ctx).should.be["false"]();
      return this.integerIntervalStartEndsFalse.exec(this.ctx).should.be["false"]();
    });
    it('should calculate decimal intervals properly', function() {
      this.decimalIntervalStartsTrue.exec(this.ctx).should.be["true"]();
      this.decimalIntervalStartsFalse.exec(this.ctx).should.be["false"]();
      return this.decimalIntervalStartsEndsFalse.exec(this.ctx).should.be["false"]();
    });
    it('should calculate quantity intervals properly', function() {
      this.quantityIntervalStartsTrue.exec(this.ctx).should.be["true"]();
      this.quantityIntervalStartsFalse.exec(this.ctx).should.be["false"]();
      return this.quantityIntervalStartsEndsFalse.exec(this.ctx).should.be["false"]();
    });
    return it('should calculate datetime intervals properly', function() {
      this.dateTimeIntervalStartsTrue.exec(this.ctx).should.be["true"]();
      this.dateTimeIntervalStartsFalse.exec(this.ctx).should.be["false"]();
      this.dateTimeIntervalStartsDayOfTrue.exec(this.ctx).should.be["true"]();
      return this.dateTimeIntervalStartsEndsFalse.exec(this.ctx).should.be["false"]();
    });
  });

  describe('Ends', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should calculate to null', function() {
      return should(this.testEndsNull.exec(this.ctx)).be["null"]();
    });
    it('should calculate integer intervals properly', function() {
      this.integerIntervalEndsTrue.exec(this.ctx).should.be["true"]();
      this.integerIntervalEndsFalse.exec(this.ctx).should.be["false"]();
      return this.integerIntervalEndsStartsFalse.exec(this.ctx).should.be["false"]();
    });
    it('should calculate decimal intervals properly', function() {
      this.decimalIntervalEndsTrue.exec(this.ctx).should.be["true"]();
      this.decimalIntervalEndsFalse.exec(this.ctx).should.be["false"]();
      return this.decimalIntervalEndsStartsFalse.exec(this.ctx).should.be["false"]();
    });
    it('should calculate quantity intervals properly', function() {
      this.quantityIntervalEndsTrue.exec(this.ctx).should.be["true"]();
      this.quantityIntervalEndsFalse.exec(this.ctx).should.be["false"]();
      return this.quantityIntervalEndsStartsFalse.exec(this.ctx).should.be["false"]();
    });
    return it('should calculate datetime intervals properly', function() {
      this.dateTimeIntervalEndsTrue.exec(this.ctx).should.be["true"]();
      this.dateTimeIntervalEndsFalse.exec(this.ctx).should.be["false"]();
      this.dateTimeIntervalEndsDayOfTrue.exec(this.ctx).should.be["true"]();
      return this.dateTimeIntervalEndsStartsFalse.exec(this.ctx).should.be["false"]();
    });
  });

  describe('IntegerIntervalUnion', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should properly calculate open and closed unions', function() {
      var x, y;
      x = this.intFullInterval.exec(this.ctx);
      y = this.intClosedUnionClosed.exec(this.ctx);
      y.equals(x).should.be["true"]();
      y = this.intClosedUnionOpen.exec(this.ctx);
      y.contains(0).should.be["true"]();
      y.contains(10).should.be["false"]();
      y = this.intOpenUnionOpen.exec(this.ctx);
      y.contains(0).should.be["false"]();
      y.contains(10).should.be["false"]();
      y = this.intOpenUnionClosed.exec(this.ctx);
      y.contains(0).should.be["false"]();
      return y.contains(10).should.be["true"]();
    });
    it('should properly calculate sameAs unions', function() {
      var x, y;
      x = this.intFullInterval.exec(this.ctx);
      y = this.intSameAsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate before/after unions', function() {
      return should(this.intBeforeUnion.exec(this.ctx)).be["null"]();
    });
    it('should properly calculate meets unions', function() {
      var x, y;
      x = this.intFullInterval.exec(this.ctx);
      y = this.intMeetsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate left/right overlapping unions', function() {
      var x, y;
      x = this.intFullInterval.exec(this.ctx);
      y = this.intOverlapsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate begins/begun by unions', function() {
      var x, y;
      x = this.intFullInterval.exec(this.ctx);
      y = this.intBeginsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate includes/included by unions', function() {
      var x, y;
      x = this.intFullInterval.exec(this.ctx);
      y = this.intDuringUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    return it('should properly calculate ends/ended by unions', function() {
      var x, y;
      x = this.intFullInterval.exec(this.ctx);
      y = this.intEndsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
  });

  describe('DateTimeIntervalUnion', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should properly calculate open and closed unions', function() {
      var a, b, x, y;
      x = this.dateTimeFullInterval.exec(this.ctx);
      y = this.dateTimeClosedUnionClosed.exec(this.ctx);
      y.equals(x).should.be["true"]();
      a = new DateTime(2012, 1, 1, 0, 0, 0, 0);
      b = new DateTime(2013, 1, 1, 0, 0, 0, 0);
      y = this.dateTimeClosedUnionOpen.exec(this.ctx);
      y.contains(a).should.be["true"]();
      y.contains(b).should.be["false"]();
      y = this.dateTimeOpenUnionOpen.exec(this.ctx);
      y.contains(a).should.be["false"]();
      y.contains(b).should.be["false"]();
      y = this.dateTimeOpenUnionClosed.exec(this.ctx);
      y.contains(a).should.be["false"]();
      return y.contains(b).should.be["true"]();
    });
    it('should properly calculate sameAs unions', function() {
      var x, y;
      x = this.dateTimeFullInterval.exec(this.ctx);
      y = this.dateTimeSameAsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate before/after unions', function() {
      return should(this.dateTimeBeforeUnion.exec(this.ctx)).be["null"]();
    });
    it('should properly calculate meets unions', function() {
      var x, y;
      x = this.dateTimeFullInterval.exec(this.ctx);
      y = this.dateTimeMeetsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate left/right overlapping unions', function() {
      var x, y;
      x = this.dateTimeFullInterval.exec(this.ctx);
      y = this.dateTimeOverlapsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate begins/begun by unions', function() {
      var x, y;
      x = this.dateTimeFullInterval.exec(this.ctx);
      y = this.dateTimeBeginsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate includes/included by unions', function() {
      var x, y;
      x = this.dateTimeFullInterval.exec(this.ctx);
      y = this.dateTimeDuringUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    return it('should properly calculate ends/ended by unions', function() {
      var x, y;
      x = this.dateTimeFullInterval.exec(this.ctx);
      y = this.dateTimeEndsUnion.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
  });

  describe('IntegerIntervalExcept', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should properly calculate sameAs except', function() {
      return should(this.intSameAsExcept.exec(this.ctx)).be["null"]();
    });
    it('should properly calculate before/after except', function() {
      return this.intBeforeExcept.exec(this.ctx).should.eql(new Interval(0, 4));
    });
    it('should properly calculate meets except', function() {
      var x, y;
      x = this.intHalfInterval.exec(this.ctx);
      y = this.intMeetsExcept.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate left/right overlapping except', function() {
      var x, y;
      x = this.intHalfInterval.exec(this.ctx);
      y = this.intOverlapsExcept.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate begins/begun by except', function() {
      return should(this.intBeginsExcept.exec(this.ctx)).be["null"]();
    });
    it('should properly calculate includes/included by except', function() {
      return should(this.intDuringExcept.exec(this.ctx)).be["null"]();
    });
    return it('should properly calculate ends/ended by except', function() {
      return should(this.intEndsExcept.exec(this.ctx)).be["null"]();
    });
  });

  describe('DateTimeIntervalExcept', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should properly calculate sameAs except', function() {
      return should(this.dateTimeSameAsExcept.exec(this.ctx)).be["null"]();
    });
    it('should properly calculate before/after except', function() {
      return this.dateTimeBeforeExcept.exec(this.ctx).should.eql(new Interval(new DateTime(2012, 1, 1, 0, 0, 0, 0), new DateTime(2012, 4, 1, 0, 0, 0, 0)));
    });
    it('should properly calculate meets except', function() {
      var x, y;
      x = this.dateTimeHalfInterval.exec(this.ctx);
      y = this.dateTimeMeetsExcept.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate left/right overlapping except', function() {
      var x, y;
      x = this.dateTimeHalfInterval.exec(this.ctx);
      y = this.dateTimeOverlapsExcept.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate begins/begun by except', function() {
      return should(this.dateTimeBeginsExcept.exec(this.ctx)).be["null"]();
    });
    it('should properly calculate includes/included by except', function() {
      return should(this.dateTimeDuringExcept.exec(this.ctx)).be["null"]();
    });
    return it('should properly calculate ends/ended by except', function() {
      return should(this.dateTimeEndsExcept.exec(this.ctx)).be["null"]();
    });
  });

  describe('IntegerIntervalIntersect', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should properly calculate sameAs intersect', function() {
      var x, y;
      x = this.intSameAsIntersect.exec(this.ctx);
      y = this.intFullInterval.exec(this.ctx);
      return x.equals(y).should.be["true"]();
    });
    it('should properly calculate before/after intersect', function() {
      return should(this.intBeforeIntersect.exec(this.ctx)).be["null"]();
    });
    it('should properly calculate meets intersect', function() {
      var x, y;
      x = this.intMeetsInterval.exec(this.ctx);
      y = this.intMeetsIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate left/right overlapping intersect', function() {
      var x, y;
      x = this.intOverlapsInterval.exec(this.ctx);
      y = this.intOverlapsIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate begins/begun by intersect', function() {
      var x, y;
      x = this.intBeginsInterval.exec(this.ctx);
      y = this.intBeginsIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate includes/included by intersect', function() {
      var x, y;
      x = this.intDuringInterval.exec(this.ctx);
      y = this.intDuringIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    return it('should properly calculate ends/ended by intersect', function() {
      var x, y;
      x = this.intEndsInterval.exec(this.ctx);
      y = this.intEndsIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
  });

  describe('DateTimeIntervalIntersect', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('should properly calculate sameAs intersect', function() {
      var x, y;
      x = this.dateTimeSameAsIntersect.exec(this.ctx);
      y = this.dateTimeFullInterval.exec(this.ctx);
      return x.equals(y).should.be["true"]();
    });
    it('should properly calculate before/after intersect', function() {
      return should(this.dateTimeBeforeIntersect.exec(this.ctx)).be["null"]();
    });
    it('should properly calculate meets intersect', function() {
      var x, y;
      x = this.dateTimeMeetsInterval.exec(this.ctx);
      y = this.dateTimeMeetsIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate left/right overlapping intersect', function() {
      var x, y;
      x = this.dateTimeOverlapsInterval.exec(this.ctx);
      y = this.dateTimeOverlapsIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate begins/begun by intersect', function() {
      var x, y;
      x = this.dateTimeBeginsInterval.exec(this.ctx);
      y = this.dateTimeBeginsIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    it('should properly calculate includes/included by intersect', function() {
      var x, y;
      x = this.dateTimeDuringInterval.exec(this.ctx);
      y = this.dateTimeDuringIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
    return it('should properly calculate ends/ended by intersect', function() {
      var x, y;
      x = this.dateTimeEndsInterval.exec(this.ctx);
      y = this.dateTimeEndsIntersect.exec(this.ctx);
      return y.equals(x).should.be["true"]();
    });
  });

  describe('IntegerIntervalCollapse', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('empty interval collapses to empty', function() {
      return this.intCollapseEmpty.exec(this.ctx).should.eql(this.intEmptyIntervalList.exec(this.ctx));
    });
    it('single interval list collapse to self', function() {
      return this.intCollapseSingleInterval.exec(this.ctx).should.eql(this.int1_10IntervalList.exec(this.ctx));
    });
    it('disjoint intervals list collapses to ordered self', function() {
      this.intCollapseDisjoint.exec(this.ctx).should.eql(this.intTwoItemDisjointList.exec(this.ctx));
      return this.intCollapseDisjointReversed.exec(this.ctx).should.eql(this.intTwoItemDisjointList.exec(this.ctx));
    });
    it('adjacent intervals list combines', function() {
      return this.intCollapseAdjacent.exec(this.ctx).should.eql(this.int1_15IntervalList.exec(this.ctx));
    });
    return it('overlapping intervals list combine', function() {
      this.intCollapseOverlap.exec(this.ctx).should.eql(this.int1_12IntervalList.exec(this.ctx));
      this.intCollapseOverlapContained.exec(this.ctx).should.eql(this.int1_15IntervalList.exec(this.ctx));
      this.intCollapseOverlapContainedEdge.exec(this.ctx).should.eql(this.int1_10IntervalList.exec(this.ctx));
      this.intCollapseOverlapContainedEdge2.exec(this.ctx).should.eql(this.int1_15IntervalList.exec(this.ctx));
      return this.intCollapseOverlapMultipleCombine.exec(this.ctx).should.eql(this.int1_15IntervalList.exec(this.ctx));
    });
  });

  describe('DateTimeIntervalCollapse', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('empty interval collapses to empty', function() {
      return this.dateTimeCollapseEmpty.exec(this.ctx).should.eql(this.dateTimeEmptyIntervalList.exec(this.ctx));
    });
    it('single interval list collapse to self', function() {
      return this.dateTimeCollapseSingleInterval.exec(this.ctx).should.eql(this.dateTime1_10IntervalList.exec(this.ctx));
    });
    it('disjoint intervals list collapses to ordered self', function() {
      return this.dateTimeCollapseDisjoint.exec(this.ctx).should.eql(this.dateTimeTwoItemDisjointList.exec(this.ctx));
    });
    it('reversed disjoint intervals list collapses to ordered self', function() {
      return this.dateTimeCollapseDisjointReversed.exec(this.ctx).should.eql(this.dateTimeTwoItemDisjointList.exec(this.ctx));
    });
    it('adjacent intervals list combines', function() {
      return this.dateTimeCollapseAdjacent.exec(this.ctx).should.eql(this.dateTime1_15IntervalList.exec(this.ctx));
    });
    it('overlapping intervals list combine', function() {
      this.dateTimeCollapseOverlap.exec(this.ctx).should.eql(this.dateTime1_12IntervalList.exec(this.ctx));
      this.dateTimeCollapseOverlapContained.exec(this.ctx).should.eql(this.dateTime1_15IntervalList.exec(this.ctx));
      this.dateTimeCollapseOverlapContainedEdge.exec(this.ctx).should.eql(this.dateTime1_10IntervalList.exec(this.ctx));
      this.dateTimeCollapseOverlapContainedEdge2.exec(this.ctx).should.eql(this.dateTime1_15IntervalList.exec(this.ctx));
      return this.dateTimeCollapseOverlapMultipleCombine.exec(this.ctx).should.eql(this.dateTime1_15IntervalList.exec(this.ctx));
    });
    it('throws collapsing imprecise interval', function() {
      return this.dateTimeCollapseImpreciseBoundary.exec(this.ctx).should.eql(this.dateTime1_10IntervalList.exec(this.ctx));
    });
    return it('should not modify collapse parameters', function() {
      var interval1CopyString, interval2CopyString, interval3CopyString;
      interval1CopyString = this.dateTime1_6Interval.toString();
      interval2CopyString = this.dateTime5_12Interval.toString();
      interval3CopyString = this.dateTime10_15Interval.toString();
      this.dateTimeCollapseOverlapMultipleCombine.exec(this.ctx);
      this.dateTime1_6Interval.toString().should.eql(interval1CopyString);
      this.dateTime5_12Interval.toString().should.eql(interval2CopyString);
      return this.dateTime10_15Interval.toString().should.eql(interval3CopyString);
    });
  });

  describe('Collapse', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('numeric collapse uses "1" as default per unit', function() {
      return this.intCollapseNoPer.exec(this.ctx).should.eql(this.intCollapsePerUnit1.exec(this.ctx));
    });
    it('combines intervals separated by less than per unit', function() {
      return this.intCollapseSeparatedListPer3.exec(this.ctx).should.eql(this.expectedIntervalList.exec(this.ctx));
    });
    it('DateTime collapse uses 1 ms as default per unit', function() {
      return this.dateTimeCollapseNoPer.exec(this.ctx).should.eql(this.dateTimeCollapsePerMs.exec(this.ctx));
    });
    it('DateTime with null end collapse with no overlap', function() {
      return this.dateTimeNullEndCollapseNoOverlap.exec(this.ctx).should.eql(this.dateTimeNullEndCollapseNoOverlapExpected.exec(this.ctx));
    });
    it('DateTime with null start collapse with no overlap', function() {
      return this.dateTimeNullStartCollapseNoOverlap.exec(this.ctx).should.eql(this.dateTimeNullStartCollapseNoOverlapExpected.exec(this.ctx));
    });
    it('combines DateTime intervals separated by less than per unit', function() {
      return this.dateTimeCollapsePerDay.exec(this.ctx).should.eql(this.dateTime1_15IntervalList.exec(this.ctx));
    });
    it('Quantity uses default per unit', function() {
      var quantity_collapse;
      quantity_collapse = this.quantityIntervalCollapseNoPer.exec(this.ctx);
      quantity_collapse.should.eql(this.expectedQuantityList.exec(this.ctx));
      return quantity_collapse.should.eql(this.quantityIntervalCollapsePerUnit1.exec(this.ctx));
    });
    it('Quantity with separated intervals', function() {
      return this.collapseSeparatedQuantity.exec(this.ctx).should.eql(this.quantitySeparatedBy3.exec(this.ctx));
    });
    it('Quantity combines disjoint intervals that are within per width', function() {
      return this.collapseSeparatedQuantityPer3.exec(this.ctx).should.eql(this.expectedSeparatedQuantity.exec(this.ctx));
    });
    it('Quantity with units uses point type as default per value', function() {
      return this.collapseDisjointQuantityUnits.exec(this.ctx).should.eql(this.expectedQuantityUnitsCollapse.exec(this.ctx));
    });
    it('Quantity with units disjoint but within per', function() {
      return this.collapseQuantityUnitsWithinPer.exec(this.ctx).should.eql(this.expectedQuantityUnitsCollapse.exec(this.ctx));
    });
    it('Quantity with units disjoint and not within per', function() {
      return this.collapseQuantityUnitsNotWithinPer.exec(this.ctx).should.eql(this.quantityMeterIntervalList.exec(this.ctx));
    });
    it('Quantity with units with null low value', function() {
      return this.collapseQuantityNullLowUnitsWithinPer.exec(this.ctx).should.eql(this.collapseQuantityNullLowUnitsWithinPerExpected.exec(this.ctx));
    });
    it('Quantity with units with null low and high values', function() {
      return this.collapseQuantityIntervalListWithNulls.exec(this.ctx).should.eql(this.collapseQuantityIntervalListWithNullsExpected.exec(this.ctx));
    });
    it('Quantity with units with null high value', function() {
      return this.collapseQuantityNullHighUnitsWithinPer.exec(this.ctx).should.eql(this.collapseQuantityNullHighUnitsWithinPerExpected.exec(this.ctx));
    });
    it('Quantity Intervals no overlap with null low', function() {
      return this.collapseQuantityIntervalListWithNullLowNoOverlap.exec(this.ctx).should.eql(this.collapseQuantityIntervalListWithNullLowNoOverlapExpected.exec(this.ctx));
    });
    it('Quantity Intervals no overlap with null high', function() {
      return this.collapseQuantityIntervalListWithNullHighNoOverlap.exec(this.ctx).should.eql(this.collapseQuantityIntervalListWithNullHighNoOverlapExpected.exec(this.ctx));
    });
    it('with Interval that has null low values', function() {
      return this.collapseNullLowIntervalList.exec(this.ctx).should.eql(this.expectedNullLowIntervalCollapse.exec(this.ctx));
    });
    it('with Interval that has null high values', function() {
      return this.collapseNullHighIntervalList.exec(this.ctx).should.eql(this.expectedNullHighIntervalCollapse.exec(this.ctx));
    });
    it('with Date Interval that has null start values', function() {
      return this.dateTimeNullStartCollapse.exec(this.ctx).should.eql(this.dateTimeNullStartCollapseExpected.exec(this.ctx));
    });
    it('with Date Interval that has null high values', function() {
      return this.dateTimeNullEndCollapse.exec(this.ctx).should.eql(this.dateTimeNullEndCollapseExpected.exec(this.ctx));
    });
    it('with Date Interval that has null high and low values', function() {
      return this.dateTimeNullStartEndCollapse.exec(this.ctx).should.eql(this.dateTimeNullStartEndCollapseExpected.exec(this.ctx));
    });
    it('should ignore nulls in list of Intervals', function() {
      return this.nullInCollapse.exec(this.ctx).should.eql(this.expectedResultWithNull.exec(this.ctx));
    });
    it.skip('should return null if list is null', function() {
      return should.not.exist(this.nullCollapse.exec(this.ctx));
    });
    return it('should use default per unit if per is expicitly null', function() {
      return this.nullPerCollapse.exec(this.ctx).should.eql(this.expectedResultNullPer.exec(this.ctx));
    });
  });

  prettyList = function(array) {
    if (array == null) {
      return array;
    }
    return '{ ' + array.join(', ') + ' }';
  };

  describe('DateIntervalExpand', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('expands a closed interval per day', function() {
      var a;
      a = this.closedSinglePerDay.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-01, 2018-01-01], [2018-01-02, 2018-01-02], [2018-01-03, 2018-01-03] }');
    });
    it('expands a closed interval per week', function() {
      var a;
      a = this.closedSinglePerWeek.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-01, 2018-01-07], [2018-01-08, 2018-01-14], [2018-01-15, 2018-01-21] }');
    });
    it('expands a closed interval per month', function() {
      var a, b;
      a = this.closedSinglePerMonth.exec(this.ctx);
      b = this.closedSinglePerMonthTrunc.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01, 2018-01-31], [2018-02-01, 2018-02-28], [2018-03-01, 2018-03-31] }');
      return prettyList(a).should.equal(prettyList(b));
    });
    it('expands a closed interval per year', function() {
      var a, b;
      a = this.closedSinglePerYear.exec(this.ctx);
      b = this.closedSinglePerYearTrunc.exec(this.ctx);
      prettyList(a).should.equal('{ [2016-01-01, 2016-12-31], [2017-01-01, 2017-12-31], [2018-01-01, 2018-12-31] }');
      return prettyList(a).should.equal(prettyList(b));
    });
    it('ignores null item in list', function() {
      var a;
      a = this.nullInList.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-01, 2018-01-01], [2018-01-02, 2018-01-02], [2018-01-03, 2018-01-03] }');
    });
    it('expands two overlapping intervals', function() {
      var a;
      a = this.overlapping.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-01, 2018-01-01], [2018-01-02, 2018-01-02], [2018-01-03, 2018-01-03], [2018-01-04, 2018-01-04] }');
    });
    it('expands two non overlapping intervals', function() {
      var a;
      a = this.nonOverlapping.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-01, 2018-01-01], [2018-01-02, 2018-01-02], [2018-01-03, 2018-01-03], [2018-01-08, 2018-01-08] }');
    });
    it('expands an interval with mid boundaries per day', function() {
      var a;
      a = this.midBoundariesPerDay.exec(this.ctx);
      return prettyList(a).should.equal('{ [2017-12-30, 2017-12-30], [2017-12-31, 2017-12-31], [2018-01-01, 2018-01-01] }');
    });
    it('expands an interval with mid boundaries per month', function() {
      var a;
      a = this.midBoundariesPerMonth.exec(this.ctx);
      return prettyList(a).should.equal('{ [2017-11-14, 2017-12-13], [2017-12-14, 2018-01-13] }');
    });
    it('expands an interval with mid boundaries per year', function() {
      var a;
      a = this.midBoundariesPerYear.exec(this.ctx);
      return prettyList(a).should.equal('{ [2016-04-06, 2017-04-05], [2017-04-06, 2018-04-05] }');
    });
    it('expands an interval with default per', function() {
      var a;
      a = this.noPerDefaultDay.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01, 2018-01-01], [2018-01-02, 2018-01-02], [2018-01-03, 2018-01-03] }');
      a = this.noPerDefaultMonth.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01, 2018-01], [2018-02, 2018-02], [2018-03, 2018-03] }');
      a = this.noPerDefaultYear.exec(this.ctx);
      prettyList(a).should.equal('{ [2016, 2016], [2017, 2017], [2018, 2018] }');
      a = this.noPerDefaultMonthWithMismatch.exec(this.ctx);
      return prettyList(a).should.equal('{ [2016, 2016], [2017, 2017], [2018, 2018] }');
    });
    it('expands interval with open ends', function() {
      var a;
      a = this.openStart.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-02, 2018-01-02], [2018-01-03, 2018-01-03] }');
      a = this.openEnd.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01, 2018-01-01], [2018-01-02, 2018-01-02] }');
      a = this.openBoth.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-02, 2018-01-02] }');
    });
    it('handles ends with mismatched precision', function() {
      var e;
      e = '{ [2018-01-01, 2018-01-31], [2018-02-01, 2018-02-28] }';
      prettyList(this.mismatchPrecision.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01, 2018-01], [2018-02, 2018-02] }';
      return prettyList(this.mismatchPrecisionEmpty.exec(this.ctx)).should.equal(e);
    });
    it('returns an empty list if we get an empty list', function() {
      var a;
      a = this.emptyList.exec(this.ctx);
      a.should.be["instanceof"](Array);
      return a.length.should.equal(0);
    });
    it('returns null with open ended intervals', function() {
      var a;
      a = this.nullOpen.exec(this.ctx);
      should.not.exist(a);
      a = this.nullClose.exec(this.ctx);
      should.not.exist(a);
      a = this.nullBoth.exec(this.ctx);
      return should.not.exist(a);
    });
    it('returns null when per is more precise than the interval ends', function() {
      var a;
      a = this.monthDayPer.exec(this.ctx);
      should.not.exist(a);
      a = this.yearMonthPer.exec(this.ctx);
      should.not.exist(a);
      a = this.yearDayPer.exec(this.ctx);
      return should.not.exist(a);
    });
    return it('returns null when per not applicable', function() {
      var a;
      a = this.badPerMinute.exec(this.ctx);
      should.not.exist(a);
      a = this.badPerGram.exec(this.ctx);
      return should.not.exist(a);
    });
  });

  describe('DateTimeIntervalExpand', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('expands a millisecond precision datetime', function() {
      var e;
      e = '{ [2016-01-01T00:00:00.000+00:00, 2016-12-31T23:59:59.999+00:00], [2017-01-01T00:00:00.000+00:00, 2017-12-31T23:59:59.999+00:00] }';
      prettyList(this.msPrecPerYear.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00:00:00.000+00:00, 2018-01-31T23:59:59.999+00:00], [2018-02-01T00:00:00.000+00:00, 2018-02-28T23:59:59.999+00:00] }';
      prettyList(this.msPrecPerMonth.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00:00:00.000+00:00, 2018-01-07T23:59:59.999+00:00], [2018-01-08T00:00:00.000+00:00, 2018-01-14T23:59:59.999+00:00] }';
      prettyList(this.msPrecPerWeek.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00:00:00.000+00:00, 2018-01-01T23:59:59.999+00:00], [2018-01-02T00:00:00.000+00:00, 2018-01-02T23:59:59.999+00:00] }';
      prettyList(this.msPrecPerDay.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01:00:00.000+00:00, 2018-01-01T01:59:59.999+00:00], [2018-01-01T02:00:00.000+00:00, 2018-01-01T02:59:59.999+00:00] }';
      prettyList(this.msPrecPerHour.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01:00:00.000+00:00, 2018-01-01T01:00:59.999+00:00], [2018-01-01T01:01:00.000+00:00, 2018-01-01T01:01:59.999+00:00] }';
      prettyList(this.msPrecPerMinute.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01:00:00.000+00:00, 2018-01-01T01:00:00.999+00:00], [2018-01-01T01:00:01.000+00:00, 2018-01-01T01:00:01.999+00:00] }';
      prettyList(this.msPrecPerSecond.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01:00:00.000+00:00, 2018-01-01T01:00:00.000+00:00], [2018-01-01T01:00:00.001+00:00, 2018-01-01T01:00:00.001+00:00] }';
      return prettyList(this.msPrecPerMillisecond.exec(this.ctx)).should.equal(e);
    });
    it('expands a second precision datetime', function() {
      var e;
      e = '{ [2016-01-01T00:00:00+00:00, 2016-12-31T23:59:59+00:00], [2017-01-01T00:00:00+00:00, 2017-12-31T23:59:59+00:00] }';
      prettyList(this.secPrecPerYear.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00:00:00+00:00, 2018-01-31T23:59:59+00:00], [2018-02-01T00:00:00+00:00, 2018-02-28T23:59:59+00:00] }';
      prettyList(this.secPrecPerMonth.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00:00:00+00:00, 2018-01-07T23:59:59+00:00], [2018-01-08T00:00:00+00:00, 2018-01-14T23:59:59+00:00] }';
      prettyList(this.secPrecPerWeek.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00:00:00+00:00, 2018-01-01T23:59:59+00:00], [2018-01-02T00:00:00+00:00, 2018-01-02T23:59:59+00:00] }';
      prettyList(this.secPrecPerDay.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01:00:00+00:00, 2018-01-01T01:59:59+00:00], [2018-01-01T02:00:00+00:00, 2018-01-01T02:59:59+00:00] }';
      prettyList(this.secPrecPerHour.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01:00:00+00:00, 2018-01-01T01:00:59+00:00], [2018-01-01T01:01:00+00:00, 2018-01-01T01:01:59+00:00] }';
      prettyList(this.secPrecPerMinute.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01:00:00+00:00, 2018-01-01T01:00:00+00:00], [2018-01-01T01:00:01+00:00, 2018-01-01T01:00:01+00:00] }';
      prettyList(this.secPrecPerSecond.exec(this.ctx)).should.equal(e);
      return should.not.exist(this.secPrecPerMillisecond.exec(this.ctx));
    });
    it('expands a minute precision datetime', function() {
      var e;
      e = '{ [2016-01-01T00:00+00:00, 2016-12-31T23:59+00:00], [2017-01-01T00:00+00:00, 2017-12-31T23:59+00:00] }';
      prettyList(this.minPrecPerYear.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00:00+00:00, 2018-01-31T23:59+00:00], [2018-02-01T00:00+00:00, 2018-02-28T23:59+00:00] }';
      prettyList(this.minPrecPerMonth.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00:00+00:00, 2018-01-07T23:59+00:00], [2018-01-08T00:00+00:00, 2018-01-14T23:59+00:00] }';
      prettyList(this.minPrecPerWeek.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00:00+00:00, 2018-01-01T23:59+00:00], [2018-01-02T00:00+00:00, 2018-01-02T23:59+00:00] }';
      prettyList(this.minPrecPerDay.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01:00+00:00, 2018-01-01T01:59+00:00], [2018-01-01T02:00+00:00, 2018-01-01T02:59+00:00] }';
      prettyList(this.minPrecPerHour.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01:00+00:00, 2018-01-01T01:00+00:00], [2018-01-01T01:01+00:00, 2018-01-01T01:01+00:00] }';
      prettyList(this.minPrecPerMinute.exec(this.ctx)).should.equal(e);
      should.not.exist(this.minPrecPerSecond.exec(this.ctx));
      return should.not.exist(this.minPrecPerMillisecond.exec(this.ctx));
    });
    it('expands an hour precision datetime', function() {
      var e;
      e = '{ [2016-01-01T00+00:00, 2016-12-31T23+00:00], [2017-01-01T00+00:00, 2017-12-31T23+00:00] }';
      prettyList(this.hourPrecPerYear.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00+00:00, 2018-01-31T23+00:00], [2018-02-01T00+00:00, 2018-02-28T23+00:00] }';
      prettyList(this.hourPrecPerMonth.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00+00:00, 2018-01-07T23+00:00], [2018-01-08T00+00:00, 2018-01-14T23+00:00] }';
      prettyList(this.hourPrecPerWeek.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T00+00:00, 2018-01-01T23+00:00], [2018-01-02T00+00:00, 2018-01-02T23+00:00] }';
      prettyList(this.hourPrecPerDay.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01T01+00:00, 2018-01-01T01+00:00], [2018-01-01T02+00:00, 2018-01-01T02+00:00] }';
      prettyList(this.hourPrecPerHour.exec(this.ctx)).should.equal(e);
      should.not.exist(this.hourPrecPerMinute.exec(this.ctx));
      should.not.exist(this.hourPrecPerSecond.exec(this.ctx));
      return should.not.exist(this.hourPrecPerMillisecond.exec(this.ctx));
    });
    it('expands a day precision datetime', function() {
      var e;
      e = '{ [2016-01-01, 2016-12-31], [2017-01-01, 2017-12-31] }';
      prettyList(this.dayPrecPerYear.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01, 2018-01-31], [2018-02-01, 2018-02-28] }';
      prettyList(this.dayPrecPerMonth.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01, 2018-01-07], [2018-01-08, 2018-01-14] }';
      prettyList(this.dayPrecPerWeek.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01-01, 2018-01-01], [2018-01-02, 2018-01-02] }';
      prettyList(this.dayPrecPerDay.exec(this.ctx)).should.equal(e);
      should.not.exist(this.dayPrecPerHour.exec(this.ctx));
      should.not.exist(this.dayPrecPerMinute.exec(this.ctx));
      should.not.exist(this.dayPrecPerSecond.exec(this.ctx));
      return should.not.exist(this.dayPrecPerMillisecond.exec(this.ctx));
    });
    it('expands a month precision datetime', function() {
      var e;
      e = '{ [2016-01, 2016-12], [2017-01, 2017-12] }';
      prettyList(this.monthPrecPerYear.exec(this.ctx)).should.equal(e);
      e = '{ [2018-01, 2018-01], [2018-02, 2018-02] }';
      prettyList(this.monthPrecPerMonth.exec(this.ctx)).should.equal(e);
      should.not.exist(this.monthPrecPerWeek.exec(this.ctx));
      should.not.exist(this.monthPrecPerDay.exec(this.ctx));
      should.not.exist(this.monthPrecPerHour.exec(this.ctx));
      should.not.exist(this.monthPrecPerMinute.exec(this.ctx));
      should.not.exist(this.monthPrecPerSecond.exec(this.ctx));
      return should.not.exist(this.monthPrecPerMillisecond.exec(this.ctx));
    });
    it('expands a year precision datetime', function() {
      var e;
      e = '{ [2016, 2016], [2017, 2017], [2018, 2018] }';
      prettyList(this.yearPrecPerYear.exec(this.ctx)).should.equal(e);
      should.not.exist(this.yearPrecPerMonth.exec(this.ctx));
      should.not.exist(this.yearPrecPerWeek.exec(this.ctx));
      should.not.exist(this.yearPrecPerDay.exec(this.ctx));
      should.not.exist(this.yearPrecPerHour.exec(this.ctx));
      should.not.exist(this.yearPrecPerMinute.exec(this.ctx));
      should.not.exist(this.yearPrecPerSecond.exec(this.ctx));
      return should.not.exist(this.yearPrecPerMillisecond.exec(this.ctx));
    });
    it('ignores null item in list', function() {
      var a;
      a = this.nullInList.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-01T01+00:00, 2018-01-01T01+00:00] }');
    });
    it('expands two overlapping intervals', function() {
      var a;
      a = this.overlapping.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-01T01+00:00, 2018-01-01T01+00:00], [2018-01-01T02+00:00, 2018-01-01T02+00:00], [2018-01-01T03+00:00, 2018-01-01T03+00:00], [2018-01-01T04+00:00, 2018-01-01T04+00:00] }');
    });
    it('expands two non overlapping intervals', function() {
      var a;
      a = this.nonOverlapping.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-01T01+00:00, 2018-01-01T01+00:00], [2018-01-01T02+00:00, 2018-01-01T02+00:00], [2018-01-01T05+00:00, 2018-01-01T05+00:00] }');
    });
    it('expands an interval with default per', function() {
      var a;
      a = this.noPerDefaultMS.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01T01:00:00.000+00:00, 2018-01-01T01:00:00.000+00:00], [2018-01-01T01:00:00.001+00:00, 2018-01-01T01:00:00.001+00:00] }');
      a = this.noPerDefaultSec.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01T01:00:00+00:00, 2018-01-01T01:00:00+00:00], [2018-01-01T01:00:01+00:00, 2018-01-01T01:00:01+00:00] }');
      a = this.noPerDefaultMin.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01T01:00+00:00, 2018-01-01T01:00+00:00], [2018-01-01T01:01+00:00, 2018-01-01T01:01+00:00] }');
      a = this.noPerDefaultHour.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01T01+00:00, 2018-01-01T01+00:00] }');
      a = this.noPerDefaultDay.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01, 2018-01-01] }');
      a = this.noPerDefaultMonth.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01, 2018-01] }');
      a = this.noPerDefaultYear.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018, 2018] }');
    });
    it('expands interval with open ends', function() {
      var a;
      a = this.openStart.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01T02+00:00, 2018-01-02T01+00:00], [2018-01-02T02+00:00, 2018-01-03T01+00:00] }');
      a = this.openEnd.exec(this.ctx);
      prettyList(a).should.equal('{ [2018-01-01T01+00:00, 2018-01-02T00+00:00], [2018-01-02T01+00:00, 2018-01-03T00+00:00] }');
      a = this.openBoth.exec(this.ctx);
      return prettyList(a).should.equal('{ [2018-01-01T02+00:00, 2018-01-02T01+00:00] }');
    });
    it('handles ends with mismatched precision', function() {
      var a, e;
      e = "{ [2012-01-01T12:00+00:00, 2012-01-02T11:59+00:00] }";
      prettyList(this.mismatchPrecision.exec(this.ctx)).should.equal(e);
      a = this.mismatchPrecisionEmpty.exec(this.ctx);
      a.should.be["instanceof"](Array);
      return a.length.should.equal(0);
    });
    it('returns an empty list if we get an empty list', function() {
      var a;
      a = this.emptyList.exec(this.ctx);
      a.should.be["instanceof"](Array);
      return a.length.should.equal(0);
    });
    it('returns null with open ended intervals', function() {
      var a;
      a = this.nullOpen.exec(this.ctx);
      should.not.exist(a);
      a = this.nullClose.exec(this.ctx);
      should.not.exist(a);
      a = this.nullBoth.exec(this.ctx);
      return should.not.exist(a);
    });
    return it('returns null when per not applicable', function() {
      var a;
      a = this.badPerGram.exec(this.ctx);
      return should.not.exist(a);
    });
  });

  describe('TimeIntervalExpand', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    xit('expands a millisecond precision datetime', function() {
      var e;
      e = '{ [T01:00:00.000+00:00, T01:59:59.999+00:00], [T02:00:00.000+00:00, T02:59:59.999+00:00] }';
      prettyList(this.msPrecPerHour.exec(this.ctx)).should.equal(e);
      e = '{ [T01:00:00.000+00:00, T01:00:59.999+00:00], [T01:01:00.000+00:00, T01:01:59.999+00:00] }';
      prettyList(this.msPrecPerMinute.exec(this.ctx)).should.equal(e);
      e = '{ [T01:00:00.000+00:00, T01:00:00.999+00:00], [T01:00:01.000+00:00, T01:00:01.999+00:00] }';
      prettyList(this.msPrecPerSecond.exec(this.ctx)).should.equal(e);
      e = '{ [T01:00:00.000+00:00, T01:00:00.000+00:00], [T01:00:00.001+00:00, T01:00:00.001+00:00] }';
      return prettyList(this.msPrecPerMillisecond.exec(this.ctx)).should.equal(e);
    });
    xit('expands a second precision datetime', function() {
      var e;
      e = '{ [T01:00:00+00:00, T01:59:59+00:00], [T02:00:00+00:00, T02:59:59+00:00] }';
      prettyList(this.secPrecPerHour.exec(this.ctx)).should.equal(e);
      e = '{ [T01:00:00+00:00, T01:00:59+00:00], [T01:01:00+00:00, T01:01:59+00:00] }';
      prettyList(this.secPrecPerMinute.exec(this.ctx)).should.equal(e);
      e = '{ [T01:00:00+00:00, T01:00:00+00:00], [T01:00:01+00:00, T01:00:01+00:00] }';
      prettyList(this.secPrecPerSecond.exec(this.ctx)).should.equal(e);
      return should.not.exist(this.secPrecPerMillisecond.exec(this.ctx));
    });
    xit('expands a minute precision datetime', function() {
      var e;
      e = '{ [T01:00+00:00, T01:59+00:00], [T02:00+00:00, T02:59+00:00] }';
      prettyList(this.minPrecPerHour.exec(this.ctx)).should.equal(e);
      e = '{ [T01:00+00:00, T01:00+00:00], [T01:01+00:00, T01:01+00:00] }';
      prettyList(this.minPrecPerMinute.exec(this.ctx)).should.equal(e);
      should.not.exist(this.minPrecPerSecond.exec(this.ctx));
      return should.not.exist(this.minPrecPerMillisecond.exec(this.ctx));
    });
    return xit('expands an hour precision datetime', function() {
      var e;
      e = '{ [T01+00:00, T01+00:00], [T02+00:00, T02+00:00] }';
      prettyList(this.hourPrecPerHour.exec(this.ctx)).should.equal(e);
      should.not.exist(this.hourPrecPerMinute.exec(this.ctx));
      should.not.exist(this.hourPrecPerSecond.exec(this.ctx));
      return should.not.exist(this.hourPrecPerMillisecond.exec(this.ctx));
    });
  });

  describe('QuantityIntervalExpand', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('expands single intervals', function() {
      var a;
      a = this.closedSingleGPerG.exec(this.ctx);
      prettyList(a).should.equal("{ [2 'g', 2 'g'], [3 'g', 3 'g'], [4 'g', 4 'g'] }");
      a = this.closedSingleGPerGDecimal.exec(this.ctx);
      prettyList(a).should.equal("{ [2.1 'g', 3.09999999 'g'], [3.1 'g', 4.09999999 'g'] }");
      a = this.closedSingleGPerMG.exec(this.ctx);
      prettyList(a).should.equal("{ [2000 'mg', 2000 'mg'], [2001 'mg', 2001 'mg'], [2002 'mg', 2002 'mg'], [2003 'mg', 2003 'mg'] }");
      a = this.closedSingleMGPerGTrunc.exec(this.ctx);
      prettyList(a).should.equal("{ [2999 'mg', 3998 'mg'] }");
      a = this.closedSingleMGPerMGTrunc.exec(this.ctx);
      prettyList(a).should.equal("{ [2000 'mg', 2799 'mg'], [2800 'mg', 3599 'mg'], [3600 'mg', 4399 'mg'] }");
      a = this.closedSingleMGPerMGDecimal.exec(this.ctx);
      return prettyList(a).should.equal("{ [2000.01 'mg', 2800.00999999 'mg'], [2800.01 'mg', 3600.0099999900003 'mg'], [3600.01 'mg', 4400.00999999 'mg'] }");
    });
    it('expands lists of multiple intervals', function() {
      var a;
      a = this.nullInList.exec(this.ctx);
      prettyList(a).should.equal("{ [2 'g', 2 'g'], [3 'g', 3 'g'], [4 'g', 4 'g'] }");
      a = this.overlapping.exec(this.ctx);
      prettyList(a).should.equal("{ [2 'g', 2 'g'], [3 'g', 3 'g'], [4 'g', 4 'g'], [5 'g', 5 'g'] }");
      a = this.nonOverlapping.exec(this.ctx);
      return prettyList(a).should.equal("{ [2 'g', 2 'g'], [3 'g', 3 'g'], [4 'g', 4 'g'], [6 'g', 6 'g'] }");
    });
    it('expands interval using the first items units if no per provided', function() {
      var a;
      a = this.noPerDefaultM.exec(this.ctx);
      prettyList(a).should.equal("{ [2 'm', 2 'm'], [3 'm', 3 'm'], [4 'm', 4 'm'] }");
      a = this.noPerDefaultG.exec(this.ctx);
      return prettyList(a).should.equal("{ [2 'g', 2 'g'], [3 'g', 3 'g'], [4 'g', 4 'g'] }");
    });
    it('expands interval with open ends', function() {
      var a;
      a = this.openStart.exec(this.ctx);
      prettyList(a).should.equal("{ [3 'g', 3 'g'], [4 'g', 4 'g'] }");
      a = this.openEnd.exec(this.ctx);
      prettyList(a).should.equal("{ [2 'g', 2 'g'], [3 'g', 3 'g'] }");
      a = this.openBoth.exec(this.ctx);
      prettyList(a).should.equal("{ [3 'g', 3 'g'] }");
      a = this.openBothDecimal.exec(this.ctx);
      prettyList(a).should.equal("{ [2.10000001 'g', 3.1 'g'] }");
      a = this.openBothDecimalTrunc.exec(this.ctx);
      return prettyList(a).should.equal("{ [2.10000001 'g', 3.1 'g'], [3.10000001 'g', 4.1 'g'] }");
    });
    it('returns an empty list if we get an empty list or if there are no results', function() {
      var a;
      a = this.emptyList.exec(this.ctx);
      a.should.be["instanceof"](Array);
      a.length.should.equal(0);
      a = this.perTooBig.exec(this.ctx);
      a.should.be["instanceof"](Array);
      return a.length.should.equal(0);
    });
    it('returns null with open ended intervals', function() {
      var a;
      a = this.nullClose.exec(this.ctx);
      should.not.exist(a);
      a = this.nullOpen.exec(this.ctx);
      should.not.exist(a);
      a = this.nullBoth.exec(this.ctx);
      return should.not.exist(a);
    });
    return it('returns null when per not applicable or mismatch interval', function() {
      var a;
      a = this.badPerMinute.exec(this.ctx);
      should.not.exist(a);
      a = this.badPerGram.exec(this.ctx);
      return should.not.exist(a);
    });
  });

  describe('IntegerIntervalExpand', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('expands single intervals', function() {
      var a;
      a = this.closedSinglePer1.exec(this.ctx);
      prettyList(a).should.equal('{ [2, 2], [3, 3], [4, 4] }');
      a = this.closedSinglePer3.exec(this.ctx);
      prettyList(a).should.equal('{ [2, 4], [5, 7], [8, 10] }');
      a = this.closedSinglePer3NoteTheWidth.exec(this.ctx);
      return prettyList(a).should.equal('{ [2, 4] }');
    });
    it('expands lists of multiple intervals', function() {
      var a;
      a = this.nullInList.exec(this.ctx);
      prettyList(a).should.equal('{ [2, 2], [3, 3], [4, 4] }');
      a = this.overlapping.exec(this.ctx);
      prettyList(a).should.equal('{ [2, 2], [3, 3], [4, 4], [5, 5] }');
      a = this.nonOverlapping.exec(this.ctx);
      return prettyList(a).should.equal('{ [2, 2], [3, 3], [4, 4], [6, 6] }');
    });
    it('expands interval using default per of 1', function() {
      var a;
      a = this.noPer.exec(this.ctx);
      return prettyList(a).should.equal('{ [2, 2], [3, 3], [4, 4] }');
    });
    it('expands interval with open ends', function() {
      var a;
      a = this.openStart.exec(this.ctx);
      prettyList(a).should.equal('{ [3, 3], [4, 4] }');
      a = this.openEnd.exec(this.ctx);
      prettyList(a).should.equal('{ [2, 2], [3, 3] }');
      a = this.openBoth.exec(this.ctx);
      return prettyList(a).should.equal('{ [3, 3] }');
    });
    it('returns an empty list if we get an empty list or if there are no results', function() {
      var a;
      a = this.emptyList.exec(this.ctx);
      a.should.be["instanceof"](Array);
      a.length.should.equal(0);
      a = this.perTooBig.exec(this.ctx);
      a.should.be["instanceof"](Array);
      return a.length.should.equal(0);
    });
    it('returns null with open ended intervals', function() {
      var a;
      a = this.nullClose.exec(this.ctx);
      should.not.exist(a);
      a = this.nullOpen.exec(this.ctx);
      should.not.exist(a);
      a = this.nullBoth.exec(this.ctx);
      return should.not.exist(a);
    });
    return it('returns null when per not applicable or mismatch interval', function() {
      var a;
      a = this.badPerMinute.exec(this.ctx);
      return should.not.exist(a);
    });
  });

  describe('DecimalIntervalExpand', function() {
    this.beforeEach(function() {
      return setup(this, data);
    });
    it('expands single intervals', function() {
      var a;
      a = this.closedSingle.exec(this.ctx);
      prettyList(a).should.equal('{ [2, 3.49999999], [3.5, 4.99999999] }');
      a = this.closedSingle1.exec(this.ctx);
      prettyList(a).should.equal('{ [2.5, 4.49999999], [4.5, 6.49999999], [6.5, 8.49999999] }');
      a = this.closedSingle2.exec(this.ctx);
      return prettyList(a).should.equal('{ [2, 2.49999999], [2.5, 2.99999999], [3, 3.49999999], [3.5, 3.99999999], [4, 4.49999999] }');
    });
    it('expands lists of multiple intervals', function() {
      var a;
      a = this.nullInList.exec(this.ctx);
      prettyList(a).should.equal('{ [2, 3.49999999], [3.5, 4.99999999] }');
      a = this.overlapping.exec(this.ctx);
      prettyList(a).should.equal('{ [2, 3.49999999], [3.5, 4.99999999], [5, 6.49999999] }');
      a = this.nonOverlapping.exec(this.ctx);
      return prettyList(a).should.equal('{ [2, 3.49999999], [6, 7.49999999] }');
    });
    it('expands interval using default per of 1', function() {
      var a;
      a = this.noPer.exec(this.ctx);
      return prettyList(a).should.equal('{ [2.5, 3.49999999], [3.5, 4.49999999] }');
    });
    it('expands interval with open ends', function() {
      var a;
      a = this.openStart.exec(this.ctx);
      prettyList(a).should.equal('{ [2.00000001, 3.5], [3.50000001, 5] }');
      a = this.openEnd.exec(this.ctx);
      prettyList(a).should.equal('{ [2, 3.49999999], [3.5, 4.99999999] }');
      a = this.openBoth.exec(this.ctx);
      return prettyList(a).should.equal('{ [2.00000001, 3.5] }');
    });
    it('returns an empty list if we get an empty list or if there are no results', function() {
      var a;
      a = this.emptyList.exec(this.ctx);
      a.should.be["instanceof"](Array);
      a.length.should.equal(0);
      a = this.perTooBig.exec(this.ctx);
      a.should.be["instanceof"](Array);
      return a.length.should.equal(0);
    });
    it('returns null with open ended intervals', function() {
      var a;
      a = this.nullClose.exec(this.ctx);
      should.not.exist(a);
      a = this.nullOpen.exec(this.ctx);
      should.not.exist(a);
      a = this.nullBoth.exec(this.ctx);
      return should.not.exist(a);
    });
    return it('returns null when per not applicable or mismatch interval', function() {
      var a;
      a = this.badPerMinute.exec(this.ctx);
      return should.not.exist(a);
    });
  });

}).call(this);

//# sourceMappingURL=test.js.map
